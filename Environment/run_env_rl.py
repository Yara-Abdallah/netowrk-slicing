import traci
from Environment import env_variables
import xml.etree.ElementTree as ET
import random
from uuid import uuid4

from Outlet.Sat.sat import Satellite
from RL.RLBuilder import RLBuilder
from RL.RLEnvironment.Action.ActionAssignment import ActionAssignment
from RL.RLEnvironment.Reward.CentralizedReward import CentralizedReward
from RL.RLEnvironment.State.CentralizedState import CentralizedState
from Utils.Bandwidth import Bandwidth
from Utils.Cost import TowerCost, RequestCost
from Utils.PerformanceLogger import PerformanceLogger
from Utils.config import outlet_types, Grids
from Vehicle.Car import Car
from Outlet.Cellular.FactoryCellular import FactoryCellular
from Vehicle.VehicleOutletObserver import ConcreteObserver
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

fig, axs = plt.subplots(nrows=5, ncols=3, figsize=(100, 32))
fig.subplots_adjust(hspace=0.8)

lines_out_utility = []
lines_out_requested = []
lines_out_ensured = []

fig_reward_decentralize, axs_reward_decentralize = plt.subplots(nrows=5, ncols=3, figsize=(100, 32))
fig_reward_decentralize.subplots_adjust(hspace=0.8)

lines_out_reward_decentralize = []

fig_reward_centralize, axs_reward_centralize = plt.subplots(nrows=5, ncols=1, figsize=(100, 32))
fig_reward_centralize.subplots_adjust(hspace=0.8)

lines_out_reward_centralize = []


fig_satellite, axs_satellite = plt.subplots(nrows=1, ncols=1, figsize=(30, 22))
fig_satellite.subplots_adjust(hspace=0.8)

lines_satellite_utility = 0
satellite_utility=[]
def plotting_satellite():
    lines_satellite_utility, = axs_satellite.plot([], [], label=f"satellite utility", color='b')
    return lines_satellite_utility


lines_satellite_utility = plotting_satellite()

def plotting_Utility_Requested_Ensured():
    j = 0
    for i in range(5):
        row = 0
        line, line1, line2 = 0, 0, 0
        for index in range(3):
            if index == 0:
                color_str = 'b'
            elif index == 1:
                color_str = 'r'
            elif index == 2:
                color_str = 'g'
            line, = axs.flatten()[j].plot([], [], label=f"O{row + index + 1} utility", color=color_str)
            line1, = axs.flatten()[j + 1].plot([], [], label=f"O{row + index + 1} requested", color=color_str)
            line2, = axs.flatten()[j + 2].plot([], [], label=f"O{row + index + 1} ensured", color=color_str)
            lines_out_utility.append(line)
            lines_out_requested.append(line1)
            lines_out_ensured.append(line2)
        j += 3


def plotting_reward_decentralize():
    for i, ax in enumerate(axs_reward_decentralize.flatten()):
        line, = ax.plot([], [], label=f"O{i + 1} reward", color='b')
        lines_out_reward_decentralize.append(line)


def plotting_reward_centralize():
    for i, ax in enumerate(axs_reward_centralize.flatten()):
        line, = ax.plot([], [], label=f"grid{i + 1} reward", color='b')
        lines_out_reward_centralize.append(line)


plotting_reward_decentralize()
plotting_reward_centralize()

plotting_Utility_Requested_Ensured()


class Environment:
    Grids = {}

    def __init__(self):
        self.polygon = traci.polygon
        self.route = traci.route
        self.vehicle = traci.vehicle
        self.poi = traci.poi
        self.gui = traci.gui
        self.simulation = traci.simulation

    def get_polygons(self):
        all_polygon_ = self.polygon.getIDList()
        return all_polygon_

    def get_buildings(self):
        all_builds_ = []
        for id_poly in self.get_polygons():
            if self.polygon.getType(id_poly) == 'building':
                all_builds_.append(id_poly)
        return all_builds_

    def prepare_route(self):
        """
        add routes to env_variables
        where the routes generated by randomTrips and store in random_routes_path
        """
        tree = ET.parse(env_variables.random_routes_path)
        root = tree.getroot()
        for child_root in root:
            # print(child_root.tag, child_root.attrib)
            id_ = child_root.attrib['id']
            for child in child_root:
                # print(child.tag, child.attrib)
                edges_ = list((child.attrib['edges']).split(' '))
                # print('the id: {}  , edges: {}'.format(id_, edges_))
                self.route.add(id_, edges_)
                env_variables.all_routes.append(id_)

    def update_outlet_color(self, id_, value):
        color_mapping = {
            (9, 10): (64, 64, 64, 255),  # dark grey
            (6, 9): (255, 0, 0, 255),  # red
            (3, 6): (0, 255, 0, 255),  # green
            (1, 3): (255, 255, 0, 255)  # yellow
        }

        for val_range, color in color_mapping.items():
            if value >= val_range[0] and value <= val_range[1]:
                traci.poi.setColor(id_, color)

    def get_all_outlets(self):
        """
        get all outlets and add id with position to env variables
        """
        outlets = []
        poi_ids = traci.poi.getIDList()

        def append_outlets(id_):
            type_poi = traci.poi.getType(id_)

            if type_poi in env_variables.types_outlets:
                position_ = traci.poi.getPosition(id_)
                env_variables.outlets[type_poi].append((id_, position_))
                # self.poi.add(id_, position_[0], position_[1],color=(255, 255, 0,255), size=100)
                factory = FactoryCellular(outlet_types[str(type_poi)], 1, 1, [1, 1, 0], id_,
                                          [position_[0], position_[1]],
                                          10000, [],
                                          [10, 10, 10])
                outlet = factory.produce_cellular_outlet(str(type_poi))
                outlet.outlet_id = id_
                outlets.append(outlet)

        list(map(lambda x: append_outlets(x), poi_ids))

        satellite = Satellite(1, 1, [1, 1, 0], 0, [0, 0],
                              10000000000, [],
                              [10, 10, 10])
        outlets.append(satellite)

        return outlets

    @staticmethod
    def fill_grids(outlets):
        Grids = {
            "grid1": [],
            "grid2": [],
            "grid3": [],
            "grid4": [],
        }
        grids = [outlets[i:i + 3] for i in range(0, len(outlets), 3)]

        def grid_namer(i, grid):
            name = "grid" + str(i + 1)
            Grids[name] = grid

        list(map(lambda x: grid_namer(x[0], x[1]), enumerate(grids)))
        return Grids

    def select_outlets_to_show_in_gui(self):
        """
        select outlets in network to display type of each outlet
        """
        # for key in env_variables.outlets.keys():
        #     for _id,_ in env_variables.outlets[key]:
        #         self.gui.toggleSelection(_id, 'poi')
        from itertools import chain
        array = list(map(lambda x: x, chain(*list(map(lambda x: x[1], env_variables.outlets.items())))))
        list(map(lambda x: self.gui.toggleSelection(x[0], 'poi'), map(lambda x: x, array)))

    def get_positions_of_outlets(self, outlets):
        positions_of_outlets = []

        list(map(lambda x: positions_of_outlets.append(x.position), outlets))
        return positions_of_outlets

    def generate_vehicles(self, number_vehicles):
        """
        It generates vehicles and adds it to the simulation
        and get random route for each vehicle from routes in env_variables.py
        :param number_vehicles: number of vehicles to be generated
        """

        all_routes = env_variables.all_routes

        def add_vehicle(id_route_):
            uid = str(uuid4())
            self.vehicle.add(vehID=uid, routeID=id_route_)

        list(map(add_vehicle, random.choices(all_routes, k=number_vehicles)))

    def starting(self):
        """
        The function starts the simulation by calling the sumoBinary, which is the sumo-gui or sumo
        depending on the nogui option
        """
        sumo_cmd = ["sumo-gui", "-c", env_variables.network_path]
        traci.start(sumo_cmd)

        # end the simulation and d

        self.prepare_route()

    def remove_vehicles_arrived(self):
        """
        Remove vehicles which removed from the road network ((have reached their destination) in this time step
        the add to env_variables.vehicles (dictionary)
        """
        ids_arrived = self.simulation.getArrivedIDList()

        def remove_vehicle(id_):
            del env_variables.vehicles[id_]

        list(map(remove_vehicle, ids_arrived))

    def add_new_vehicles(self):
        """
        Add vehicles which inserted into the road network in this time step.
        the add to env_variables.vehicles (dictionary)
        """
        ids_new_vehicles = self.simulation.getDepartedIDList()

        def create_vehicle(id_):
            env_variables.vehicles[id_] = Car(id_, 0, 0)

        list(map(create_vehicle, ids_new_vehicles))

    def outlets_logging(self, outlet_num, outlet, cars):
        return f"Outlet {outlet_num} : -> {outlet}   -  Number Of Cars Which Send Request To It -> {len(cars)} \n "

    def car_services_logging(self, car_num, car, service):
        return f"  The Car {car_num} Which Send To It -> : {car} \n" \
               f"     And Its Services Is  ->  : {service} \n"

    def logging_the_final_results(self, performance_logger):
        service_handled = performance_logger.service_handled

        for i, outer_key in enumerate(service_handled):
            num = 0
            print(self.outlets_logging(i, outer_key, service_handled[outer_key]))
            for key, value in performance_logger.service_handled[outer_key].items():
                num += 1
                print(self.car_services_logging(num, key, value))

    def get_current_vehicles(self):
        """
        :return: vehicles that running in road network in this time step
        """
        self.remove_vehicles_arrived()
        self.add_new_vehicles()
        return env_variables.vehicles

    def ensured_service_aggrigation(self, performance_logger, outlet, service_type, action_value):

        if outlet not in performance_logger._outlet_services_ensured_number:
            performance_logger.set_outlet_services_ensured_number(outlet, [0, 0, 0])

        if str(service_type) == "FactorySafety":
            service_ensured_value = performance_logger.outlet_services_ensured_number[outlet][0]
            if action_value == 1:
                performance_logger.outlet_services_ensured_number[outlet][0] = int(service_ensured_value) + 1

        elif str(service_type) == "FactoryEntertainment":
            service_ensured_value = performance_logger.outlet_services_ensured_number[outlet][1]
            if action_value == 1:
                performance_logger.outlet_services_ensured_number[outlet][1] = int(service_ensured_value) + 1

        elif str(service_type) == "FactoryAutonomous":
            service_ensured_value = performance_logger.outlet_services_ensured_number[outlet][2]
            if action_value == 1:
                performance_logger.outlet_services_ensured_number[outlet][2] = int(service_ensured_value) + 1

    """"""

    def services_aggregation(self, performance_logger, outlet, service_type, request_cost):
        if outlet not in performance_logger._outlet_services_requested_number:
            performance_logger.set_outlet_services_requested_number(outlet, [0, 0, 0])

        if str(service_type) == "FactorySafety":
            num = performance_logger.outlet_services_requested_number[outlet][0]
            performance_logger.outlet_services_requested_number[outlet][0] = int(num) + 1

        elif str(service_type) == "FactoryEntertainment":
            num = performance_logger.outlet_services_requested_number[outlet][1]
            performance_logger.outlet_services_requested_number[outlet][1] = int(num) + 1

        elif str(service_type) == "FactoryAutonomous":
            num = performance_logger.outlet_services_requested_number[outlet][2]
            performance_logger.outlet_services_requested_number[outlet][2] = int(num) + 1

    def power_aggregation(self, performance_logger, outlet, service_type, request_cost, action_value):
        if outlet not in performance_logger._outlet_services_power_allocation:
            performance_logger.set_outlet_services_power_allocation(outlet, [0.0, 0.0, 0.0])

        if str(service_type) == "FactorySafety":

            x = performance_logger.outlet_services_power_allocation[outlet][0]
            if action_value == 1:
                performance_logger.outlet_services_power_allocation[outlet][0] = float(x) + float(
                    request_cost)


        elif str(service_type) == "FactoryEntertainment":
            x = performance_logger.outlet_services_power_allocation[outlet][1]
            if action_value == 1:
                performance_logger.outlet_services_power_allocation[outlet][1] = float(x) + float(
                    request_cost)


        elif str(service_type) == "FactoryAutonomous":
            x = performance_logger.outlet_services_power_allocation[outlet][2]
            if action_value == 1:
                performance_logger.outlet_services_power_allocation[outlet][2] = float(x) + float(
                    request_cost)

    def car_interact(self, car, observer, performance_logger, gridcells_dqn, outlets):
        # car.outlets_serve.append(outlets[-1])

        car.attach(observer)
        car.set_state(car.get_x(), car.get_y())

        car.add_satellite(outlets[-1])

        info = car.send_request()
        car = info[1][1]
        service = info[1][2]
        outlet = info[0]

        # print("outlet is : ", outlet)
        # print("outlet . max capacity : ",outlet.max_capacity)

        performance_logger.service_requested = {car: service}
        # .................................................................................................
        performance_logger.set_service_handled(outlet, info[1][1], service)
        request_bandwidth = Bandwidth(service.bandwidth, service.criticality)
        request_cost = RequestCost(request_bandwidth, service.realtime)
        request_cost.cost_setter(service.realtime)
        # print(f"request cost from car {car.get_id()} : ->  {service.__class__.__name__, service.bandwidth, request_cost.cost} \n ")
        performance_logger.request_costs.append(request_cost.cost)
        performance_logger.set_service_power_allocate(service, request_bandwidth.allocated)
        self.services_aggregation(performance_logger, outlet, service.__class__.__name__, request_cost.cost)

        # print("performance logger occupancy : ", performance_logger.outlet_occupancy)

        if len(outlet.power_distinct[0]) == 0:
            outlet.power = [0.0, 0.0, 0.0]
            performance_logger.set_outlet_services_requested_number(outlet, [0, 0, 0])
            performance_logger.set_outlet_services_ensured_number(outlet, [0, 0, 0])
            performance_logger.set_outlet_utility(outlet, 0.0)
            performance_logger.set_outlet_occupancy(outlet, 0.0)
            performance_logger.set_centralized_reward(outlet.dqn.agents, 0.0)

        outlet.dqn.environment.state.services_requested = performance_logger.outlet_services_requested_number[outlet]
        outlet.dqn.environment.reward.services_requested = performance_logger.outlet_services_requested_number[outlet]
        # print(f" outlet service requested : {outlet} , {outlet.dqn.environment.state.services_requested}")

        self.ensured_service_aggrigation(performance_logger, outlet, service.__class__.__name__,
                                         outlet.dqn.agents.action_value)
        self.power_aggregation(performance_logger, outlet, service.__class__.__name__, request_cost.cost,
                               outlet.dqn.agents.action_value)

        outlet.power = performance_logger.outlet_services_power_allocation[outlet]
        # print("outlet power is ........................ :  ", outlet.power)
        tower_cost = TowerCost(request_bandwidth, service.realtime)
        tower_cost.cost_setter(service.realtime)
        performance_logger.power_costs.append(tower_cost.cost)
        # print(f"bandwidth_demand is:{request_bandwidth.allocated:.2f} ")

        cost2 = 0
        if outlet.dqn.agents.action_value == 1:
            cost2 = outlet.max_capacity - request_bandwidth.allocated
            # print(f"capacity is: {outlet.max_capacity} MBps outlet type : {outlet.__class__.__name__}")
            # print(f"tower capacity after send request from  {car.get_id()} : ->  {cost2} \n ")
            tower_cost.cost = cost2

        outlet.dqn.environment.state.allocated_power = outlet.power
        outlet.dqn.environment.state.tower_capacity = cost2

        occupancy = sum(performance_logger.outlet_services_power_allocation[outlet]) / outlet.max_capacity
        # print(f"sum : {sum(performance_logger.outlet_services_power_allocation[outlet])}  max {outlet.max_capacity} ")
        # print(f"dev :  {sum(performance_logger.outlet_services_power_allocation[outlet])/outlet.max_capacity}")

        outlet.sum_of_service_requested_power_allocation = sum(
            performance_logger.outlet_services_power_allocation[outlet])
        outlet.occupancy = int(occupancy * 100)
        # print("outlet occupancy :  ", outlet.occupancy)

        performance_logger.set_outlet_occupancy(outlet, outlet.occupancy)

        outlet.dqn.environment.state.services_ensured = performance_logger.outlet_services_ensured_number[outlet]
        outlet.dqn.environment.reward.services_ensured = performance_logger.outlet_services_ensured_number[outlet]
        # print(f" outlet service ensured : {outlet} , {outlet.dqn.environment.state.services_ensured}")

        if sum(outlet.dqn.environment.state.services_requested) == 0 and sum(
                outlet.dqn.environment.state.services_ensured) == 0:
            outlet.utility = 0
        elif sum(outlet.dqn.environment.state.services_requested) != 0 and sum(
                outlet.dqn.environment.state.services_ensured) != 0:
            outlet.utility = int((sum(outlet.dqn.environment.state.services_ensured) / sum(
                outlet.dqn.environment.state.services_requested)) * 10)

        else:
            outlet.utility = 0

        if outlet.__class__.__name__ == 'Satellite':
            # print("satellite_utility : ", outlet.utility)
            satellite_utility.append(outlet.utility)

        performance_logger.set_outlet_utility(outlet, outlet.utility)
        # print("outlet.utility : ", outlet.utility)
        # print("outlet.dqn.agents.epsilon ....... : ", outlet.dqn.agents.epsilon)

        state_value_decentralize = outlet.dqn.environment.state.calculate_state()
        # print("state value for decentralize : ", state_value_decentralize)

        action_decentralize, action_value_decentralize = outlet.dqn.agents.chain(outlet.dqn.model,
                                                                                 state_value_decentralize,
                                                                                 outlet.dqn.agents.epsilon)

        # print("action_value for Decentralized agent   ", action_value_decentralize)
        outlet.dqn.agents.action_value = action_value_decentralize
        next_state_decentralize = action_decentralize.execute(outlet.dqn.environment.state,
                                                              action_value_decentralize)

        reward_value_decentralize = outlet.dqn.environment.reward.calculate_reward()
        for ind, gridcell_dqn in enumerate(gridcells_dqn):

            # gridcell_dqn.environment.state.resetsate()
            # gridcell_dqn.environment.reward.resetreward()
            gridcell_dqn.environment.state.services_requested = [0.0, 0.0, 0.0]
            gridcell_dqn.environment.reward.services_requested = [0.0, 0.0, 0.0]
            gridcell_dqn.environment.state.services_ensured = [0.0, 0.0, 0.0]
            gridcell_dqn.environment.reward.services_ensured = [0.0, 0.0, 0.0]

            sum_of_utility_of_all_outlets = [0, 0, 0]
            ratio_of_utility = [0, 0, 0]
            sum_ = 0

            for i, outlet in enumerate(gridcell_dqn.agents.grid_outlets):
                if len(outlet.power_distinct[0]) == 0:
                    outlet.power = [0.0, 0.0, 0.0]
                    performance_logger.set_outlet_services_requested_number(outlet, [0, 0, 0])
                    performance_logger.set_outlet_services_ensured_number(outlet, [0, 0, 0])
                    performance_logger.set_outlet_utility(outlet, 0.0)
                    performance_logger.set_outlet_occupancy(outlet, 0.0)
                    performance_logger.set_centralized_reward(gridcell_dqn.agents, 0.0)
                    performance_logger.set_decentralized_reward(outlet.dqn.agents, 0.0)

                outlet.distinct = gridcell_dqn.agents.outlets_id[i]
                gridcell_dqn.environment.state.allocated_power = outlet.power_distinct
                gridcell_dqn.environment.state.tower_capacity = cost2
                gridcell_dqn.environment.state.supported_services = outlet.supported_services_distinct
                gridcell_dqn.environment.state.filtered_powers = gridcell_dqn.environment.state.allocated_power

                gridcell_dqn.environment.state.services_requested += outlet.dqn.environment.state.services_requested
                gridcell_dqn.environment.reward.services_requested += outlet.dqn.environment.reward.services_requested
                gridcell_dqn.environment.state.services_ensured += outlet.dqn.environment.state.services_ensured
                gridcell_dqn.environment.reward.services_ensured += outlet.dqn.environment.reward.services_ensured
                #
                # print(f"service requested in grid {ind} , {gridcell_dqn.environment.state.services_requested}")
                # print(f"service requested in outlet {i} , {outlet.dqn.environment.state.services_requested}")
                #
                # print(f"service ensured in grid {ind} , {gridcell_dqn.environment.state.services_ensured}")
                # print(f"service ensured in outlet {i} , {outlet.dqn.environment.state.services_ensured}")

                sum_of_utility_of_all_outlets = sum_of_utility_of_all_outlets + outlet.dqn.environment.reward.calculate_reward()

            state_value_centralize = gridcell_dqn.environment.state.calculate_state(
                gridcell_dqn.environment.state.supported_services)
            action_centralize, action_value_centralize = gridcell_dqn.agents.chain(gridcell_dqn.model,
                                                                                   state_value_centralize,
                                                                                   gridcell_dqn.agents.epsilon)
            next_state_centralize = action_centralize.execute(gridcell_dqn.environment.state, action_value_centralize)
            reward_value_centralize = gridcell_dqn.environment.reward.calculate_reward()

            for index in range(3):
                if sum_of_utility_of_all_outlets[index] != 0:
                    ratio_of_utility[index] = reward_value_centralize[index] / sum_of_utility_of_all_outlets[index]

            for k, outlet in enumerate(gridcell_dqn.agents.grid_outlets):
                outlet.dqn.environment.reward.reward_value = sum(
                    outlet.dqn.environment.reward.calculate_reward() * ratio_of_utility) / 3
                # print(f"reward value outlet {k} , {outlet.dqn.environment.reward.reward_value}")
                outlet.dqn.agents.remember(state_value_decentralize, action_value_decentralize,
                                           outlet.dqn.environment.reward.reward_value, next_state_decentralize)
                state_value_decentralize = next_state_decentralize

            gridcell_dqn.environment.reward.reward_value = sum(reward_value_centralize) / 3
            # print(f"reward value grid {ind} , {gridcell_dqn.environment.reward.reward_value}")
            gridcell_dqn.agents.remember(state_value_centralize, action_value_centralize,
                                         gridcell_dqn.environment.reward.reward_value,
                                         next_state_centralize)

    def terminate_service(self, veh, outlets, performance_logger):
        for out in outlets:
            if out not in veh.outlets_serve:
                if out in performance_logger.service_handled:
                    if veh in performance_logger.service_handled[out]:
                        serv = performance_logger.service_handled[out][veh]
                        # print("performance_logger.service_power_allocate[serv] : ", performance_logger.service_power_allocate[serv])
                        out._max_capacity = out._max_capacity + performance_logger.service_power_allocate[serv]
            else :
                out._max_capacity = out._max_capacity

    def run(self):
        gridcells_dqn = []
        self.starting()

        outlets = self.get_all_outlets()

        self.Grids = self.fill_grids(outlets)
        step = 0
        print("\n")
        outlets_pos = self.get_positions_of_outlets(outlets)
        observer = ConcreteObserver(outlets_pos, outlets)
        performance_logger = PerformanceLogger()

        build1 = RLBuilder()
        build2 = RLBuilder()
        build3 = RLBuilder()
        build4 = RLBuilder()
        build5 = RLBuilder()

        gridcell_dqn1 = build1.agent.build_agent(ActionAssignment()).environment.build_env(CentralizedReward(),
                                                                                           CentralizedState()).model_.build_model(
            "centralized", 6, 9).build()
        gridcell_dqn1.agents.grid_outlets = self.Grids.get("grid1")
        gridcell_dqn1.agents.outlets_id = list(range(len(gridcell_dqn1.agents.grid_outlets)))

        gridcell_dqn2 = build2.agent.build_agent(ActionAssignment()).environment.build_env(CentralizedReward(),
                                                                                           CentralizedState()).model_.build_model(
            "centralized", 6, 9).build()
        gridcell_dqn2.agents.grid_outlets = self.Grids.get("grid2")
        gridcell_dqn2.agents.outlets_id = list(range(len(gridcell_dqn2.agents.grid_outlets)))

        gridcell_dqn3 = build3.agent.build_agent(ActionAssignment()).environment.build_env(CentralizedReward(),
                                                                                           CentralizedState()).model_.build_model(
            "centralized", 6, 9).build()
        gridcell_dqn3.agents.grid_outlets = self.Grids.get("grid3")
        gridcell_dqn3.agents.outlets_id = list(range(len(gridcell_dqn3.agents.grid_outlets)))

        gridcell_dqn4 = build4.agent.build_agent(ActionAssignment()).environment.build_env(CentralizedReward(),
                                                                                           CentralizedState()).model_.build_model(
            "centralized", 6, 9).build()
        gridcell_dqn4.agents.grid_outlets = self.Grids.get("grid4")
        gridcell_dqn4.agents.outlets_id = list(range(len(gridcell_dqn4.agents.grid_outlets)))

        gridcell_dqn5 = build5.agent.build_agent(ActionAssignment()).environment.build_env(CentralizedReward(),
                                                                                           CentralizedState()).model_.build_model(
            "centralized", 6, 9).build()
        gridcell_dqn5.agents.grid_outlets = self.Grids.get("grid5")
        gridcell_dqn5.agents.outlets_id = list(range(len(gridcell_dqn5.agents.grid_outlets)))

        gridcells_dqn.append(gridcell_dqn1)
        gridcells_dqn.append(gridcell_dqn2)
        gridcells_dqn.append(gridcell_dqn3)
        gridcells_dqn.append(gridcell_dqn4)
        gridcells_dqn.append(gridcell_dqn5)

        steps = 0

        # Initialize previous_steps variable
        previous_steps = 0
        snapshot_time = 2
        prev = 0
        temp_outlet_reward = []
        poi_ids = traci.poi.getIDList()
        temp_outlets = []

        for i in range(5):
            for index, outlet in enumerate(gridcells_dqn[i].agents.grid_outlets):
                temp_outlets.append(outlet)

        while step < env_variables.TIME:
            steps += 1
            traci.simulationStep()
            print("step is ....................................... ", step)
            self.get_current_vehicles()
            if step == 0:
                self.generate_vehicles(250)
                self.select_outlets_to_show_in_gui()
            list(map(lambda veh: self.car_interact(veh, observer, performance_logger, gridcells_dqn, outlets),
                     env_variables.vehicles.values()))

            list(map(lambda veh: self.terminate_service(veh, outlets, performance_logger),
                     env_variables.vehicles.values()))

            # for i in range(5):
            #     for index, outlet in enumerate(gridcells_dqn[i].agents.grid_outlets):
            #         outlet_utility[i][index] = outlet.utility

            # self.update_outlet_utility(outlet_utility)
            # self.update_outlet_occupancy(outlet_occupancy)
            for i in range(5):
                for index, outlet in enumerate(gridcells_dqn[i].agents.grid_outlets):
                    self.update_outlet_color(outlet.outlet_id, outlet.utility)

            for j, line in enumerate(lines_out_utility):
                x_data, y_data = line.get_data()
                x_data = np.append(x_data, steps)
                y_data = np.append(y_data, temp_outlets[j].utility)
                # print(x_data.shape, " utility ", y_data.shape, "outlet num : ", j, " value : ",
                #       temp_outlets[j].utility)  # print the shape

                line.set_data(x_data, y_data)

            for j, line1 in enumerate(lines_out_requested):
                x_data, y_data = line1.get_data()
                x_data = np.append(x_data, steps)
                y_data = np.append(y_data, sum(temp_outlets[j].dqn.environment.state.services_requested))
                # print(x_data.shape, " requested ", y_data.shape, "outlet num : ", j, " value : ",
                #       sum(temp_outlets[j].dqn.environment.state.services_requested))  # print the shape

                line1.set_data(x_data, y_data)

            for j, line2 in enumerate(lines_out_ensured):
                x_data, y_data = line2.get_data()
                x_data = np.append(x_data, steps)
                y_data = np.append(y_data, sum(temp_outlets[j].dqn.environment.state.services_ensured))
                # print(x_data.shape, " 3 ", y_data.shape, "outlet num : ", j, " value : ",
                #       sum(temp_outlets[j].dqn.environment.state.services_ensured))  # print the shape

                line2.set_data(x_data, y_data)

            for j, line3 in enumerate(lines_out_reward_decentralize):
                x_data, y_data = line3.get_data()
                x_data = np.append(x_data, steps)
                y_data = np.append(y_data, temp_outlets[j].dqn.environment.reward.reward_value)
                # print(x_data.shape, " 4 ", y_data.shape, "outlet num : ", j, " value : ",
                #       temp_outlets[j].dqn.environment.reward.reward_value)
                line3.set_data(x_data, y_data)

            for j, line4 in enumerate(lines_out_reward_centralize):
                x_data, y_data = line4.get_data()
                x_data = np.append(x_data, steps)
                y_data = np.append(y_data, gridcells_dqn[j].environment.reward.reward_value)
                # print(x_data.shape, " 5 ", y_data.shape, "outlet num : ", j, " value : ",
                #       gridcells_dqn[j].environment.reward.reward_value)
                line4.set_data(x_data, y_data)

            axs_satellite.legend()
            axs_satellite.relim()
            axs_satellite.autoscale_view()

            # fig_satellite.canvas.draw()

            for axs_ in [axs, axs_reward_decentralize, axs_reward_centralize]:
                for ax in axs_.flatten():
                    ax.legend()
                    ax.relim()
                    ax.autoscale_view()
                # Draw the figure after each loop
                if axs is axs:
                    fig.canvas.draw()
                elif axs is axs_reward_decentralize:
                    fig_reward_decentralize.canvas.draw()
                else:
                    fig_reward_centralize.canvas.draw()



            if steps - prev == snapshot_time:
                prev = steps
                path1 = f'I://Documents//utility_requested_ensured//snapshot{steps}'
                path2 = f'I://Documents//reward_decentralized//snapshot{steps}'
                path3 = f'I://Documents//reward_centralized//snapshot{steps}'
                path4 = f'I://Documents//rl_satellite//snapshot{steps}'
                fig.savefig(path1 + '.png')
                fig_reward_decentralize.savefig(path2 + '.png')
                fig_reward_centralize.savefig(path3 + '.png')
                fig_satellite.savefig(path4 + '.png')
                plt.pause(0.001)

            if steps % 2 == 0:
                plt.pause(0.001)

            if steps - previous_steps >= 30:
                previous_steps = steps
                for ind, gridcell_dqn in enumerate(gridcells_dqn):
                    for i, outlet in enumerate(gridcell_dqn.agents.grid_outlets):
                        performance_logger.set_decentralized_reward(outlet.dqn.agents,
                                                                    outlet.dqn.environment.reward.reward_value)

                        performance_logger.set_centralized_reward(gridcell_dqn.agents,
                                                                  gridcell_dqn.environment.reward.reward_value
                                                                  )

                        # performance_logger.set_outlet_services_requested_number(outlet, [0, 0, 0])
                        # performance_logger.set_outlet_services_ensured_number(outlet, [0, 0, 0])
                        # performance_logger.set_outlet_utility(outlet, 0.0)
                        # performance_logger.set_outlet_occupancy(outlet, 0.0)
                        # performance_logger.set_outlet_services_power_allocation(outlet, [0.0, 0.0, 0.0])
                        if len(outlet.dqn.agents.memory) > outlet.dqn.agents.batch_size:
                            print("replay buffer of decentralize ")
                            outlet.dqn.agents.replay_buffer_decentralize(outlet.dqn.agents.batch_size, outlet.dqn.model)
                        # outlet.dqn.environment.state.resetsate(outlet.max_capacity)

            if steps - previous_steps >= 24 * 30:
                previous_steps = steps
                for ind, gridcell_dqn in enumerate(gridcells_dqn):
                    if len(gridcell_dqn.agents.memory) > gridcell_dqn.agents.batch_size:
                        print("replay buffer of centralize ")
                        gridcell_dqn.agents.replay_buffer_centralize(gridcell_dqn.agents.batch_size,
                                                                     gridcell_dqn.model)
                    # gridcell_dqn.environment.state.resetsate()

            step += 1
            if step == 24 * 60 * 7:
                self.logging_the_final_results(performance_logger)
                break

        plt.show()
        plt.close()
        traci.close()
