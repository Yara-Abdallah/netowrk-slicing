import numpy
import traci
from Environment import env_variables
import xml.etree.ElementTree as ET
import random
from uuid import uuid4
from Outlet.Cellular.ThreeG import ThreeG
from RL.RLBuilder import RLBuilder
from RL.RLEnvironment.Action.ActionAssignment import ActionAssignment
from RL.RLEnvironment.Reward.CentralizedReward import CentralizedReward
from RL.RLEnvironment.State.CentralizedState import CentralizedState
from Utils.Bandwidth import Bandwidth
from Utils.Cost import TowerCost, RequestCost
from Utils.PerformanceLogger import PerformanceLogger
from Utils.config import outlet_types, Grids
from Vehicle.Car import Car
from Outlet.Cellular.FactoryCellular import FactoryCellular
from Vehicle.VehicleOutletObserver import ConcreteObserver
import numpy as np

# from Utils.FileLoggingInfo import Logger


class Environment:
    Grids = {}

    def __init__(self):
        self.polygon = traci.polygon
        self.route = traci.route
        self.vehicle = traci.vehicle
        self.poi = traci.poi
        self.gui = traci.gui
        self.simulation = traci.simulation

    def get_polygons(self):
        all_polygon_ = self.polygon.getIDList()
        return all_polygon_

    def get_buildings(self):
        all_builds_ = []
        for id_poly in self.get_polygons():
            if self.polygon.getType(id_poly) == 'building':
                all_builds_.append(id_poly)
        return all_builds_

    def prepare_route(self):
        """
        add routes to env_variables
        where the routes generated by randomTrips and store in random_routes_path
        """
        tree = ET.parse(env_variables.random_routes_path)
        root = tree.getroot()
        for child_root in root:
            # print(child_root.tag, child_root.attrib)
            id_ = child_root.attrib['id']
            for child in child_root:
                # print(child.tag, child.attrib)
                edges_ = list((child.attrib['edges']).split(' '))
                # print('the id: {}  , edges: {}'.format(id_, edges_))
                self.route.add(id_, edges_)
                env_variables.all_routes.append(id_)

    def get_all_outlets(self):
        """
        get all outlets and add id with position to env variables
        """
        outlets = []
        poi_ids = traci.poi.getIDList()
        for id_ in poi_ids:
            type_poi = traci.poi.getType(id_)
            if type_poi in env_variables.types_outlets:
                position_ = traci.poi.getPosition(id_)
                env_variables.outlets[type_poi].append((id_, position_))
                print()
                factory = FactoryCellular(outlet_types[str(type_poi)], 1, 1, [1, 1, 0], [position_[0], position_[1]],
                                          10000, [],
                                          [10, 10, 10])
                outlet = factory.produce_cellular_outlet(str(type_poi))
                outlets.append(outlet)
        return outlets

    @staticmethod
    def fill_grids(outlets):
        Grids = {
            "grid1": [],
            "grid2": [],
            "grid3": [],
            "grid4": [],
        }
        grids = [outlets[i:i + 3] for i in range(0, len(outlets), 3)]
        num = 1
        for i, grid in enumerate(grids):
            name = "grid" + str(num)
            Grids[name] = grid
            num = num + 1
        return Grids

    def select_outlets_to_show_in_gui(self):
        """
        select outlets in network to display type of each outlet
        """
        for key in env_variables.outlets.keys():
            for id_, _ in env_variables.outlets[key]:
                self.gui.toggleSelection(id_, 'poi')

    def get_positions_of_outlets(self, outlets):
        positions_of_outlets = []

        for out in outlets:
            positions_of_outlets.append(out.position)
        return positions_of_outlets

    def generate_vehicles(self, number_vehicles):
        """
        It generates vehicles and adds it to the simulation
        and get random route for each vehicle from routes in env_variables.py
        :param number_vehicles: number of vehicles to be generated
        """
        for i in range(number_vehicles):
            id_route_ = random.choice(env_variables.all_routes)
            uid = str(uuid4())
            self.vehicle.add(vehID=uid, routeID=id_route_)

    def starting(self):
        """
        The function starts the simulation by calling the sumoBinary, which is the sumo-gui or sumo
        depending on the nogui option
        """
        sumo_cmd = ["sumo-gui", "-c", env_variables.network_path]
        traci.start(sumo_cmd)

        self.prepare_route()

    def remove_vehicles_arrived(self):
        """
        Remove vehicles which removed from the road network ((have reached their destination) in this time step
        the add to env_variables.vehicles (dictionary)
        """
        ids_arrived = self.simulation.getArrivedIDList()
        for id_ in ids_arrived:
            del env_variables.vehicles[id_]

    def add_new_vehicles(self):
        """
        Add vehicles which inserted into the road network in this time step.
        the add to env_variables.vehicles (dictionary)
        """
        ids_new_vehicles = self.simulation.getDepartedIDList()
        for id_ in ids_new_vehicles:
            env_variables.vehicles[id_] = Car(id_, 0, 0)

    def outlets_logging(self, outlet_num, outlet, cars):
        return f"Outlet {outlet_num} : -> {outlet}   -  Number Of Cars Which Send Request To It -> {len(cars)} \n "

    def car_services_logging(self, car_num, car, service):
        return f"  The Car {car_num} Which Send To It -> : {car} \n" \
               f"     And Its Services Is  ->  : {service} \n"

    def logging_the_final_results(self, performance_logger):
        service_handled = performance_logger.service_handled
        for i, outer_key in enumerate(service_handled):
            num = 0
            print(self.outlets_logging(i, outer_key, service_handled[outer_key]))
            for key, value in performance_logger.service_handled[outer_key].items():
                num += 1
                print(self.car_services_logging(num, key, value))

    def get_current_vehicles(self):
        """
        :return: vehicles that running in road network in this time step
        """
        self.remove_vehicles_arrived()
        self.add_new_vehicles()
        return env_variables.vehicles

    def services_aggregation(self, performance_logger, outlet, service_type, request_cost):
        if outlet not in performance_logger._outlet_services_power_allocation:
            performance_logger.set_outlet_services_power_allocation(outlet, [0.0, 0.0, 0.0])
        if outlet not in performance_logger._outlet_services_requested_number:
            performance_logger.set_outlet_services_requested_number(outlet, [0, 0, 0])
        if str(service_type) == "FactorySafety":
            x = performance_logger.outlet_services_power_allocation[outlet][0]
            num = performance_logger.outlet_services_requested_number[outlet][0]
            performance_logger.outlet_services_power_allocation[outlet][0] = float(x) + float(
                request_cost)
            performance_logger.outlet_services_requested_number[outlet][0] = int(num) + 1
        elif str(service_type) == "FactoryEntertainment":
            x = performance_logger.outlet_services_power_allocation[outlet][1]
            num = performance_logger.outlet_services_requested_number[outlet][1]
            performance_logger.outlet_services_power_allocation[outlet][1] = float(x) + float(
                request_cost)
            performance_logger.outlet_services_requested_number[outlet][1] = int(num) + 1

        elif str(service_type) == "FactoryAutonomous":
            x = performance_logger.outlet_services_power_allocation[outlet][2]
            num = performance_logger.outlet_services_requested_number[outlet][2]
            performance_logger.outlet_services_power_allocation[outlet][2] = float(x) + float(
                request_cost)
            performance_logger.outlet_services_requested_number[outlet][2] = int(num) + 1

    def car_interact(self, car, observer, performance_logger, grid_outlets, builder):
        car.attach(observer)
        car.set_state(car.get_x(), car.get_y())
        info = car.send_request()
        car = info[1][1]
        service = info[1][2]
        outlet = info[0]
        performance_logger.service_requested = {car: service}
        performance_logger.set_service_handled(outlet, car, service)
        request_bandwidth = Bandwidth(service.bandwidth, service.criticality)
        request_cost = RequestCost(request_bandwidth, service.realtime)
        request_cost.cost_setter(service.realtime)
        print(
            f"request cost from car {car.get_id()} : ->  {service.__class__.__name__, service.bandwidth, request_cost.cost} \n ")
        performance_logger.request_costs.append(request_cost.cost)
        self.services_aggregation(performance_logger, outlet, service.__class__.__name__, request_cost.cost)
        outlet.power = performance_logger.outlet_services_power_allocation[outlet]
        print("outlet power is ........................ :  ", outlet.power)
        tower_cost = TowerCost(request_bandwidth, service.realtime)
        tower_cost.cost = service.realtime
        performance_logger.power_costs.append(tower_cost.cost)
        print(f"bandwidth_demand is:{request_bandwidth.allocated:.2f} ")
        cost2 = outlet.max_capacity - request_bandwidth.allocated
        print(f"capacity is: {outlet.max_capacity} MBps outlet type : {outlet.__class__.__name__}")
        print(f"tower cost after send request from  {car.get_id()} : ->  {cost2} \n ")

        for outlet in grid_outlets:
            if len(outlet.power_distinct[0]) == 0:
                outlet.power = [0.0, 0.0, 0.0]
                performance_logger.set_outlet_services_requested_number(outlet, [0, 0, 0])
            builder.environment.state.allocated_power = outlet.power_distinct
            builder.environment.state.supported_services = outlet.supported_services_distinct
            builder.environment.state.filtered_powers = builder.environment.state.allocated_power
            builder.environment.state.services_requested = performance_logger.outlet_services_requested_number[outlet]
            builder.environment.reward.services_requested = performance_logger.outlet_services_requested_number[outlet]

        builder.agents.train(builder)
        # state_value = builder.environment.state.calculate_state(builder.environment.state.supported_services)
        # print("state_value  ", state_value)
        #
        # reward_value = builder.environment.reward.calculate_reward()
        # print("reward value : ", reward_value)
        #
        # action, action_value = builder.agents.chain(builder.model, state_value, 0.1)
        # print("action_value  ", action_value)
        # next_state = action.execute(builder.environment.state, action_value)
        # print("next state  ", next_state)
        # builder.agents.remember(state_value, action_value, reward_value, next_state)

    def run(self):
        self.starting()
        outlets = self.get_all_outlets()
        self.Grids = self.fill_grids(outlets)
        step = 0
        print("\n")
        outlets_pos = self.get_positions_of_outlets(outlets)
        observer = ConcreteObserver(outlets_pos, outlets)
        performance_logger = PerformanceLogger()

        build = RLBuilder()
        builder = build.agent.build_agent(ActionAssignment()).environment.build_env(CentralizedReward(),
                                                                                    CentralizedState()).model_.build_model().build()
        # builder1 = build.agent.build_agent().environment.build_env().model_.build_model().build()
        # builder2 = build.agent.build_agent().environment.build_env().model_.build_model().build()
        # builder3 = build.agent.build_agent().environment.build_env().model_.build_model().build()
        builder.agents.grid_outlets = self.Grids.get("grid1")
        # builder1.agents.grid_outlets = self.Grids.get("grid2")
        # builder2.agents.grid_outlets = self.Grids.get("grid3")
        # builder3.agents.grid_outlets = self.Grids.get("grid4")
        print("grid1 ", builder.agents.grid_outlets)
        # print("grid2 ", builder.agents.grid_outlets)
        # print("grid3 ", builder.agents.grid_outlets)
        # print("grid4 ", builder.agents.grid_outlets)

        while step < env_variables.TIME:
            traci.simulationStep()
            print("step is ....................................... ", step)
            self.get_current_vehicles()
            if step == 0:
                self.generate_vehicles(150)
                self.select_outlets_to_show_in_gui()
            list(map(lambda veh: self.car_interact(veh, observer, performance_logger, builder.agents.grid_outlets,
                                                   builder), env_variables.vehicles.values()))


            step += 1
            if step == 10:
                self.logging_the_final_results(performance_logger)
                break
        traci.close()
