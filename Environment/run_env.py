import numpy
import traci
from Environment import env_variables
import xml.etree.ElementTree as ET
import random
from uuid import uuid4
from Outlet.Cellular.ThreeG import ThreeG
from RL.RLBuilder import RLBuilder
from RL.RLEnvironment.Action.ActionAssignment import ActionAssignment
from RL.RLEnvironment.Reward.CentralizedReward import CentralizedReward
from RL.RLEnvironment.State.CentralizedState import CentralizedState
from Utils.Bandwidth import Bandwidth
from Utils.Cost import TowerCost, RequestCost
from Utils.PerformanceLogger import PerformanceLogger
from Utils.config import outlet_types, Grids
from Vehicle.Car import Car
from Outlet.Cellular.FactoryCellular import FactoryCellular
from Vehicle.VehicleOutletObserver import ConcreteObserver
import numpy as np


# from Utils.FileLoggingInfo import Logger


class Environment:
    Grids = {}

    def __init__(self):
        self.polygon = traci.polygon
        self.route = traci.route
        self.vehicle = traci.vehicle
        self.poi = traci.poi
        self.gui = traci.gui
        self.simulation = traci.simulation

    def get_polygons(self):
        all_polygon_ = self.polygon.getIDList()
        return all_polygon_

    def get_buildings(self):
        all_builds_ = []
        for id_poly in self.get_polygons():
            if self.polygon.getType(id_poly) == 'building':
                all_builds_.append(id_poly)
        return all_builds_

    def prepare_route(self):
        """
        add routes to env_variables
        where the routes generated by randomTrips and store in random_routes_path
        """
        tree = ET.parse(env_variables.random_routes_path)
        root = tree.getroot()
        for child_root in root:
            # print(child_root.tag, child_root.attrib)
            id_ = child_root.attrib['id']
            for child in child_root:
                # print(child.tag, child.attrib)
                edges_ = list((child.attrib['edges']).split(' '))
                # print('the id: {}  , edges: {}'.format(id_, edges_))
                self.route.add(id_, edges_)
                env_variables.all_routes.append(id_)

    def get_all_outlets(self):
        """
        get all outlets and add id with position to env variables
        """
        outlets = []
        poi_ids = traci.poi.getIDList()

        def append_outlets(id_):
            type_poi = traci.poi.getType(id_)
            if type_poi in env_variables.types_outlets:
                position_ = traci.poi.getPosition(id_)
                env_variables.outlets[type_poi].append((id_, position_))
                print()
                factory = FactoryCellular(outlet_types[str(type_poi)], 1, 1, [1, 1, 0], [position_[0], position_[1]],
                                          10000, [],
                                          [10, 10, 10])
                outlet = factory.produce_cellular_outlet(str(type_poi))
                outlets.append(outlet)

        list(map(lambda x: append_outlets(x), poi_ids))
        return outlets

    @staticmethod
    def fill_grids(outlets):
        Grids = {
            "grid1": [],
            "grid2": [],
            "grid3": [],
            "grid4": [],
        }
        grids = [outlets[i:i + 3] for i in range(0, len(outlets), 3)]

        def grid_namer(i, grid):
            name = "grid" + str(i + 1)
            Grids[name] = grid

        list(map(lambda x: grid_namer(x[0], x[1]), enumerate(grids)))

        return Grids

    def select_outlets_to_show_in_gui(self):
        """
        select outlets in network to display type of each outlet
        """
        from itertools import chain
        array = list(map(lambda x: x, chain(*list(map(lambda x: x[1], env_variables.outlets.items())))))
        list(map(lambda x: self.gui.toggleSelection(x[0], 'poi'), map(lambda x: x, array)))

    def get_positions_of_outlets(self, outlets):
        positions_of_outlets = []

        list(map(lambda x: positions_of_outlets.append(x.position), outlets))
        return positions_of_outlets

    def generate_vehicles(self, number_vehicles):
        """
        It generates vehicles and adds it to the simulation
        and get random route for each vehicle from routes in env_variables.py
        :param number_vehicles: number of vehicles to be generated
        """

        all_routes = env_variables.all_routes

        def add_vehicle(id_route_):
            uid = str(uuid4())
            self.vehicle.add(vehID=uid, routeID=id_route_)

        list(map(add_vehicle, random.choices(all_routes, k=number_vehicles)))

        # for i in range(number_vehicles):
        #     id_route_ = random.choice(env_variables.all_routes)
        #     uid = str(uuid4())
        #     self.vehicle.add(vehID=uid, routeID=id_route_)

    def starting(self):
        """
        The function starts the simulation by calling the sumoBinary, which is the sumo-gui or sumo
        depending on the nogui option
        """
        sumo_cmd = ["sumo-gui", "-c", env_variables.network_path]
        traci.start(sumo_cmd)

        self.prepare_route()

    def remove_vehicles_arrived(self):
        """
        Remove vehicles which removed from the road network ((have reached their destination) in this time step
        the add to env_variables.vehicles (dictionary)
        """
        ids_arrived = self.simulation.getArrivedIDList()

        def remove_vehicle(id_):
            del env_variables.vehicles[id_]

        list(map(remove_vehicle, ids_arrived))

    def add_new_vehicles(self):
        """
        Add vehicles which inserted into the road network in this time step.
        the add to env_variables.vehicles (dictionary)
        """
        ids_new_vehicles = self.simulation.getDepartedIDList()

        def create_vehicle(id_):
            env_variables.vehicles[id_] = Car(id_, 0, 0)

        list(map(create_vehicle, ids_new_vehicles))

    def outlets_logging(self, outlet_num, outlet, cars):
        return f"Outlet {outlet_num} : -> {outlet}   -  Number Of Cars Which Send Request To It -> {len(cars)} \n "

    def car_services_logging(self, car_num, car, service):
        return f"  The Car {car_num} Which Send To It -> : {car} \n" \
               f"     And Its Services Is  ->  : {service} \n"

    def logging_the_final_results(self, performance_logger):
        service_handled = performance_logger.service_handled

        for i, outer_key in enumerate(service_handled):
            num = 0
            print(self.outlets_logging(i, outer_key, service_handled[outer_key]))
            for key, value in performance_logger.service_handled[outer_key].items():
                num += 1
                print(self.car_services_logging(num, key, value))

    def get_current_vehicles(self):
        """
        :return: vehicles that running in road network in this time step
        """
        self.remove_vehicles_arrived()
        self.add_new_vehicles()
        return env_variables.vehicles

    def ensured_service_aggrigation(self, performance_logger, outlet, service_type, action_value):

        if outlet not in performance_logger._outlet_services_ensured_number:
            performance_logger.set_outlet_services_ensured_number(outlet, [0, 0, 0])

        if str(service_type) == "FactorySafety":
            service_ensured_value = performance_logger.outlet_services_ensured_number[outlet][0]
            if action_value == 1:
                performance_logger.outlet_services_ensured_number[outlet][0] = int(service_ensured_value) + 1

        elif str(service_type) == "FactoryEntertainment":
            service_ensured_value = performance_logger.outlet_services_ensured_number[outlet][1]
            if action_value == 1:
                performance_logger.outlet_services_ensured_number[outlet][1] = int(service_ensured_value) + 1

        elif str(service_type) == "FactoryAutonomous":
            service_ensured_value = performance_logger.outlet_services_ensured_number[outlet][2]
            if action_value == 1:
                performance_logger.outlet_services_ensured_number[outlet][2] = int(service_ensured_value) + 1

    def services_aggregation(self, performance_logger, outlet, service_type, request_cost):
        if outlet not in performance_logger._outlet_services_power_allocation:
            performance_logger.set_outlet_services_power_allocation(outlet, [0.0, 0.0, 0.0])
        if outlet not in performance_logger._outlet_services_requested_number:
            performance_logger.set_outlet_services_requested_number(outlet, [0, 0, 0])

        if str(service_type) == "FactorySafety":
            x = performance_logger.outlet_services_power_allocation[outlet][0]
            num = performance_logger.outlet_services_requested_number[outlet][0]
            performance_logger.outlet_services_power_allocation[outlet][0] = float(x) + float(
                request_cost)
            performance_logger.outlet_services_requested_number[outlet][0] = int(num) + 1

        elif str(service_type) == "FactoryEntertainment":
            x = performance_logger.outlet_services_power_allocation[outlet][1]
            num = performance_logger.outlet_services_requested_number[outlet][1]
            performance_logger.outlet_services_power_allocation[outlet][1] = float(x) + float(
                request_cost)
            performance_logger.outlet_services_requested_number[outlet][1] = int(num) + 1

        elif str(service_type) == "FactoryAutonomous":
            x = performance_logger.outlet_services_power_allocation[outlet][2]
            num = performance_logger.outlet_services_requested_number[outlet][2]
            performance_logger.outlet_services_power_allocation[outlet][2] = float(x) + float(
                request_cost)
            performance_logger.outlet_services_requested_number[outlet][2] = int(num) + 1

    def car_interact(self, car, observer, performance_logger, grid_outlets, gridcell_dqn):
        car.attach(observer)
        car.set_state(car.get_x(), car.get_y())
        info = car.send_request()
        car = info[1][1]
        service = info[1][2]
        outlet = info[0]
        performance_logger.service_requested = {car: service}
        performance_logger.set_service_handled(outlet, car, service)
        request_bandwidth = Bandwidth(service.bandwidth, service.criticality)
        request_cost = RequestCost(request_bandwidth, service.realtime)
        request_cost.cost_setter(service.realtime)
        print(
            f"request cost from car {car.get_id()} : ->  {service.__class__.__name__, service.bandwidth, request_cost.cost} \n ")
        performance_logger.request_costs.append(request_cost.cost)
        self.services_aggregation(performance_logger, outlet, service.__class__.__name__, request_cost.cost)
        outlet.power = performance_logger.outlet_services_power_allocation[outlet]
        print("outlet power is ........................ :  ", outlet.power)
        tower_cost = TowerCost(request_bandwidth, service.realtime)
        tower_cost.cost_setter(service.realtime)
        performance_logger.power_costs.append(tower_cost.cost)
        print(f"bandwidth_demand is:{request_bandwidth.allocated:.2f} ")
        cost2 = outlet.max_capacity - request_bandwidth.allocated
        print(f"capacity is: {outlet.max_capacity} MBps outlet type : {outlet.__class__.__name__}")
        print(f"tower capacity after send request from  {car.get_id()} : ->  {cost2} \n ")
        tower_cost.cost = cost2

        if len(outlet.power_distinct[0]) == 0:
            outlet.power = [0.0, 0.0, 0.0]
            performance_logger.set_outlet_services_requested_number(outlet, [0, 0, 0])
            performance_logger.set_outlet_services_ensured_number(outlet, [0, 0, 0])
        print("outlet.power_distinct : ", outlet.power)
        outlet.dqn.environment.state.allocated_power = outlet.power
        print("outlet.dqn.environment.state.allocated_power>>>>>>>>>>>>>>>>> ",
              outlet.dqn.environment.state.allocated_power)
        outlet.dqn.environment.state.tower_capacity = cost2
        outlet.dqn.environment.state.services_requested = performance_logger.outlet_services_requested_number[outlet]
        outlet.dqn.environment.reward.services_requested = performance_logger.outlet_services_requested_number[outlet]

        self.ensured_service_aggrigation(performance_logger, outlet, service.__class__.__name__,
                                         outlet.dqn.agents.action_value)

        outlet.dqn.environment.state.services_ensured = performance_logger.outlet_services_ensured_number[outlet]
        outlet.dqn.environment.reward.services_ensured = performance_logger.outlet_services_ensured_number[outlet]
        #
        state_value_decentralize = outlet.dqn.environment.state.calculate_state()
        print("state value for decentralize : ", state_value_decentralize)

        action_decentralize, action_value_decentralize = outlet.dqn.agents.chain(outlet.dqn.model,
                                                                                 state_value_decentralize, 0.1)

        print("action_value for Decentralized agent   ", action_value_decentralize)
        outlet.dqn.agents.action_value = action_value_decentralize
        next_state_decentralize = action_decentralize.execute(outlet.dqn.environment.state,
                                                              action_value_decentralize)
        print(f"services requested become : ..............  ", outlet.dqn.environment.state.services_requested)
        print("request ensured become : ..............  ", outlet.dqn.environment.state.services_ensured)
        print("next state for Decentralized agent  ", next_state_decentralize)
        reward_value_decentralize = outlet.dqn.environment.reward.calculate_reward()
        print("reward value for Decentralized agent    ", reward_value_decentralize)
        # next_state_decentralize = np.reshape(next_state_decentralize, [1, np.array(next_state_decentralize).shape[0]])



        gridcell_dqn.environment.state.resetsate()
        gridcell_dqn.environment.reward.resetreward()
        sum_of_utility_of_all_outlets=[0,0,0]
        ratio_of_utility = 0
        sum_ = 0
        for i, outlet in enumerate(gridcell_dqn.agents.grid_outlets):
            if len(outlet.power_distinct[0]) == 0:
                outlet.power = [0.0, 0.0, 0.0]
                performance_logger.set_outlet_services_requested_number(outlet, [0, 0, 0])
                performance_logger.set_outlet_services_ensured_number(outlet, [0, 0, 0])
            print(
                f"services requested  for outlet  {i} become ,{outlet.dqn.environment.state.services_requested}, ........")

            print(f"outlet.dqn.environment.reward.calculate_reward() for outlet .....  {i} is {outlet.dqn.environment.reward.calculate_reward()}")

            gridcell_dqn.environment.state.allocated_power = outlet.power_distinct
            gridcell_dqn.environment.state.tower_capacity = cost2
            gridcell_dqn.environment.state.supported_services = outlet.supported_services_distinct
            gridcell_dqn.environment.state.filtered_powers = gridcell_dqn.environment.state.allocated_power



            gridcell_dqn.environment.state.services_requested += outlet.dqn.environment.state.services_requested
            gridcell_dqn.environment.reward.services_requested += outlet.dqn.environment.reward.services_requested
            gridcell_dqn.environment.state.services_ensured += outlet.dqn.environment.state.services_ensured
            gridcell_dqn.environment.reward.services_ensured += outlet.dqn.environment.reward.services_ensured
            sum_of_utility_of_all_outlets = sum_of_utility_of_all_outlets + outlet.dqn.environment.reward.calculate_reward()





        state_value_centralize = gridcell_dqn.environment.state.calculate_state(
            gridcell_dqn.environment.state.supported_services)
        action_centralize, action_value_centralize = gridcell_dqn.agents.chain(gridcell_dqn.model,
                                                                               state_value_centralize, 0.1)
        print("action value _centralize: ", action_value_centralize)
        next_state_centralize = action_centralize.execute(gridcell_dqn.environment.state, action_value_centralize)
        print("next_state value _centralize: ", next_state_centralize)
        reward_value_centralize = gridcell_dqn.environment.reward.calculate_reward()
        print("reward value _centralize : ", reward_value_centralize)
        print("ratio >>> ", sum_of_utility_of_all_outlets)
        ratio_of_utility = reward_value_centralize/sum_of_utility_of_all_outlets
        print("reward_value_centralize/sum_of_utility_of_all_outlets ....................  ",ratio_of_utility)

        for outlet in gridcell_dqn.agents.grid_outlets:
            outlet.dqn.environment.reward.reward_value = outlet.dqn.environment.reward.calculate_reward()*ratio_of_utility
            print("decentralize reward >>> ... ", outlet.dqn.environment.reward.reward_value)

            outlet.dqn.agents.remember(state_value_decentralize, action_value_decentralize,
                                       outlet.dqn.environment.reward.reward_value, next_state_decentralize)
            state_value_decentralize = next_state_decentralize





        print("gridcell_dqn.environment.reward.services_requested   ... ",gridcell_dqn.environment.reward.services_requested)
        print("gridcell_dqn.environment.reward.services_ensured     ...",gridcell_dqn.environment.reward.services_ensured)

        gridcell_dqn.agents.remember(state_value_centralize, action_value_centralize, reward_value_centralize,next_state_centralize)

        state_value_centralize = next_state_centralize


    def run(self):
        self.starting()
        outlets = self.get_all_outlets()
        self.Grids = self.fill_grids(outlets)
        step = 0
        print("\n")
        outlets_pos = self.get_positions_of_outlets(outlets)
        observer = ConcreteObserver(outlets_pos, outlets)
        performance_logger = PerformanceLogger()

        build = RLBuilder()

        gridcell_dqn = build.agent.build_agent(ActionAssignment()).environment.build_env(CentralizedReward(),
                                                                                         CentralizedState()).model_.build_model(
            "centralized", 6, 9).build()

        gridcell_dqn.agents.grid_outlets = self.Grids.get("grid1")
        print("grid1 ", gridcell_dqn.agents.grid_outlets)

        steps = 0

        # Initialize previous_steps variable
        previous_steps = 0
        while step < env_variables.TIME:
            steps += 1
            traci.simulationStep()
            print("step is ....................................... ", step)
            self.get_current_vehicles()
            if step == 0:
                self.generate_vehicles(150)
                self.select_outlets_to_show_in_gui()
            list(map(lambda veh: self.car_interact(veh, observer, performance_logger, gridcell_dqn.agents.grid_outlets,
                                                   gridcell_dqn), env_variables.vehicles.values()))

            if steps - previous_steps >= 30:
                # Update previous_steps to current value of steps
                previous_steps = steps
                # train centralize
                gridcell_dqn.environment.state.resetsate()
                state_value_centralize = gridcell_dqn.environment.state.calculate_state(
                    gridcell_dqn.environment.state.supported_services)
                print("state value for centralize : ", state_value_centralize)
                if len(gridcell_dqn.agents.memory) > gridcell_dqn.agents.batch_size:
                    # print("replay buffer of centralize >>>>>>>")
                    gridcell_dqn.agents.replay_buffer_centralize(gridcell_dqn.agents.batch_size, gridcell_dqn.model)
                for outlet in gridcell_dqn.agents.grid_outlets:
                    outlet.dqn.environment.state.resetsate(outlet.max_capacity)
                    if len(outlet.dqn.agents.memory) > outlet.dqn.agents.batch_size:
                        # print("replay buffer of Decentralize >>>>>>>")
                        outlet.dqn.agents.replay_buffer_decentralize(outlet.dqn.agents.batch_size, outlet.dqn.model)

            step += 1
            if step == 60 * 24:
                self.logging_the_final_results(performance_logger)
                break
        traci.close()
