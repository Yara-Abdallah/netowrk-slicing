# import numpy as np
import traci
from Environment import env_variables
import xml.etree.ElementTree as ET
import random
from uuid import uuid4
from Outlet.Cellular.ThreeG import ThreeG
from Vehicle.Car import Car
from Outlet.Cellular.FactoryCellular import FactoryCellular
from Vehicle.VehicleOutletObserver import ConcreteObserver


class Environment:
    def __init__(self):
        self.polygon = traci.polygon
        self.route = traci.route
        self.vehicle = traci.vehicle
        self.poi = traci.poi
        self.gui = traci.gui

    def get_polygons(self):
        all_polygon_ = self.polygon.getIDList()
        return all_polygon_

    def get_buildings(self):
        all_builds_ = []
        for id_poly in self.get_polygons():
            if self.polygon.getType(id_poly) == 'building':
                all_builds_.append(id_poly)
        return all_builds_

    def prepare_route(self):
        """
        add routes to env_variables
        where the routes generated by randomTrips and store in random_routes_path
        """
        tree = ET.parse(env_variables.random_routes_path)
        root = tree.getroot()
        for child_root in root:
            # print(child_root.tag, child_root.attrib)
            id_ = child_root.attrib['id']
            for child in child_root:
                # print(child.tag, child.attrib)
                edges_ = list((child.attrib['edges']).split(' '))
                # print('the id: {}  , edges: {}'.format(id_, edges_))
                self.route.add(id_, edges_)
                env_variables.all_routes.append(id_)

    def generate_vehicles(self,number_vehicles):
        """
        It generates vehicles and adds it to the simulation
        and get random route for each vehicle from routes in env_variables.py
        :param number_vehicles: number of vehicles to be generated
        """
        for i in range(number_vehicles):
            id_route_ = random.choice(env_variables.all_routes)
            uid = str(uuid4())
            # veh = Car(id_=uid, route_=id_route_)
            # env_variables.vehicles.append(veh)
            self.vehicle.add(vehID='Veh' + uid, routeID=id_route_)

    def get_all_outlets(self):
        """
        get all outlets and add id with position to env variables
        """
        outlets=[]
        poi_ids = traci.poi.getIDList()
        for id_ in poi_ids:
            type_poi = traci.poi.getType(id_)
            if type_poi in env_variables.types_outlets:
                position_ = traci.poi.getPosition(id_)
                env_variables.outlets[type_poi].append((id_, position_))
                factory = FactoryCellular(1,1,[1,1,0],[position_[0],position_[1]],10000,[10,20,30],[10,10,10])
                outlet=factory.produce_cellular_outlet(str(type_poi))
                outlets.append(outlet)
        return outlets

    def select_outlets_to_show_in_gui(self):
        """
        select outlets in network to display type of each outlet
        """
        for key in env_variables.outlets.keys():
            for id_, _ in env_variables.outlets[key]:
                self.gui.toggleSelection(id_, 'poi')

    def get_positions_of_outlets(self):
        positions_of_outlets = []
        outlets = self.get_all_outlets()
        for out in outlets:
            positions_of_outlets.append(out.position)
        return positions_of_outlets

    def get_position_all_vehicles(self, id_vehicles):
        """
        get ids and positions of vehicles which running in simulation and add they to env variables
        :param id_vehicles: list of ids vehicles
        :return:
        """
        env_variables.vehicles_id_pos = list(map(lambda id_: (id_, traci.vehicle.getPosition(id_)), id_vehicles))

    def get_positions_of_outlets(self):
        positions_of_outlets = []
        for key in env_variables.outlets.keys():
            positions_of_outlets.extend(list(map(lambda id_: id_[1], env_variables.outlets[key])))
        return positions_of_outlets
    def starting(self):
        """
        The function starts the simulation by calling the sumoBinary, which is the sumo-gui or sumo
        depending on the nogui option
        """
        sumoCmd = ["sumo-gui", "-c", env_variables.network_path]
        traci.start(sumoCmd)
        self.get_all_outlets()
        self.prepare_route()

    def get_current_vehicles(self):
        def veh_isruning(veh):
            return True if veh.get_id() in self.vehicle.getIDList() else False

        current_vehs = list(map(lambda veh: veh, filter(lambda veh: veh_isruning(veh) , env_variables.vehicles)))
        env_variables.vehicles = current_vehs
        return env_variables.vehicles

    def run(self):
        self.starting()
        step = 0
        outlets_pos = self.get_positions_of_outlets()
        observer = ConcreteObserver(outlets_pos)
        # self.generate_vehicles(5)
        while step < env_variables.TIME:
            traci.simulationStep()

            # id_veh = traci.vehicle.getIDList()[0]
            if step % 200 == 0:
                self.generate_vehicles(150)
                print(self.vehicle.getIDCount())
                print(len(self.get_current_vehicles()))

            if step == 0:
                self.generate_vehicles(150)
                self.select_outlets_to_show_in_gui()

            for index, i in enumerate(traci.vehicle.getIDList()):
                veh_position = traci.vehicle.getPosition(i)
                print("car ..... id ", index)
                # print("in time step .... ", step)
                car1 = Car(index, veh_position[0], veh_position[1])
                car1.attach(observer)
                car1.set_state(veh_position[0], veh_position[1])
            step += 1

        traci.close()













